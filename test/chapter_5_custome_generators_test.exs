defmodule Chapter5CustomGeneratorsTest do
  @moduledoc """
  This chapter is very PropEr specific, which is fair enough.

  Limiting generated strings fell out naturally in WordCountTest / chapter 4.

  This chapter implies that some combinations (eg "") won't be likely to be
  generated by PropEr in the default 100 iterations; StreamData does, as it
  favours with smaller sized values first: empty strings, arrays, etc...

  The reporters for data distribution don't seem to be in StreamData.

  There's nothing like `collect/1` and `aggregate/1` in StreamData ...
  """
  use ExUnit.Case
  use ExUnitProperties
  import PropTestSupport

  describe "stats reporting proof of concept" do
    setup context do
      %{test: test_name} = context
      # Only for a single property as a proof of concept.
      {:ok, stat_collector} = Agent.start(fn -> [] end)

      collect = fn value ->
        Agent.update(stat_collector, fn values -> [value | values] end)
      end

      on_exit(fn ->
        IO.puts("")
        IO.puts(test_name)
        IO.puts("------------")

        stat_collector
        |> Agent.get(fn values -> element_counts(values) end)
        |> Enum.sort_by(fn {_value, count} -> count end)
        |> Enum.map(fn {value, count} -> IO.puts("#{count}:\t#{inspect(value)}") end)

        Agent.stop(stat_collector)
      end)

      {:ok, collector: collect}
    end

    property "mimics PropEr's `collect`", context do
      %{collector: collect} = context

      check all bin <- binary() do
        collect.(to_range(10, byte_size(bin)))
      end
    end

    property "collect with resize", context do
      %{collector: collect} = context

      check all bin <- resize(binary(), 150) do
        collect.(to_range(25, byte_size(bin)))
      end
    end

    defp to_range(m, n) do
      base = div(n, m)
      {base * m, (base + 1) * m}
    end
  end

  property "naive queue" do
    check all list <- list_of(integer()) do
      q = :queue.from_list(list)
      assert :queue.is_queue(q)
    end
  end

  property "nicer queue" do
    check all q <- queue() do
      assert :queue.is_queue(q)
    end
  end

  defp queue do
    bind(list_of(integer()), fn i -> constant(:queue.from_list(i)) end)
  end

  property "non empty" do
    check all list_or_bin <- list_or_binary(), list_or_bin != [] && list_or_bin != <<>> do
      cond do
        is_list(list_or_bin) ->
          assert length(list_or_bin) > 0

        is_binary(list_or_bin) ->
          assert byte_size(list_or_bin) > 0

        true ->
          flunk()
      end
    end
  end

  defp list_or_binary do
    frequency([{1, list_of(integer())}, {1, binary()}])
  end

  property "text like" do
    IO.puts("")
    IO.puts("Text like")
    IO.puts("________")

    check all tl <- text_like(), max_runs: 13 do
      IO.puts(Enum.join(tl, " "))
    end
  end

  # To me this seems to generate more text like output than
  # following the frequencies in the original
  defp text_like do
    list_of(
      frequency([
        {8, string([?a..?z, ?A..?Z], min_length: 1, max_length: 12)},
        {1, string([?\n, ?., ?-, ?!, ?,], max_length: 1)},
        {2, string(?0..?9)}
      ])
    )
  end
end
